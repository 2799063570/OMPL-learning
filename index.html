<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D 粒子手势交互</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';

// --- 1. 场景初始化 ---
const scene = new THREE.Scene();
// 添加一些迷雾以增强深度感
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// --- 2. 粒子系统参数设置 ---
const PARTICLE_COUNT = 15000; // 粒子数量
const DISPERSION = 40; // 分布范围
const INTERACTION_RADIUS = 8; // 鼠标影响半径
const MOUSE_FORCE = 2.0; // 鼠标斥力强度
const RETURN_SPEED = 0.05; // 回到原位的速度 (弹性系数)
const DAMPING = 0.90; // 阻尼/摩擦力 (防止无限振荡)

// --- 3. 创建粒子几何体和数据 ---
const particlesGeometry = new THREE.BufferGeometry();
const posArray = new Float32Array(PARTICLE_COUNT * 3); // 当前位置 [x,y,z, x,y,z...]
const originalPosArray = new Float32Array(PARTICLE_COUNT * 3); // 记录初始位置
const velocityArray = new Float32Array(PARTICLE_COUNT * 3); // 速度向量

// 初始化粒子位置
for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
    // 创建一个球形分布
    const radius = Math.random() * DISPERSION;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos((Math.random() * 2) - 1);

    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    
    posArray[i] = x;
    posArray[i + 1] = y;
    posArray[i + 2] = z;

    // 保存初始位置
    originalPosArray[i] = posArray[i];
    originalPosArray[i + 1] = posArray[i + 1];
    originalPosArray[i + 2] = posArray[i + 2];

    // 初始速度为0
    velocityArray[i] = 0;
    velocityArray[i+1] = 0;
    velocityArray[i+2] = 0;
}

// 将数据绑定到几何体属性
particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

// --- 4. 创建材质并组合为点云网格 ---
// 创建一个小圆点纹理，比默认方块好看
function createCircleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.beginPath();
    ctx.arc(32, 32, 30, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}

const particlesMaterial = new THREE.PointsMaterial({
    size: 0.4,
    map: createCircleTexture(),
    transparent: true,
    opacity: 0.8,
    color: 0x00aaff, // 青蓝色
    blending: THREE.AdditiveBlending, // 发光叠加效果
    depthWrite: false // 防止粒子自身遮挡
});

const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particleSystem);


// --- 5. 交互逻辑设置 ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(9999, 9999); // 初始在屏幕外
const mouse3DVec = new THREE.Vector3();
// 创建一个不可见的平面，用于接收鼠标射线，确定 Z=0 的交互位置
const planeGeo = new THREE.PlaneGeometry(200, 200);
const planeMat = new THREE.MeshBasicMaterial({ visible: false });
const interactionPlane = new THREE.Mesh(planeGeo, planeMat);
scene.add(interactionPlane);

function onMouseMove(event) {
    // 将鼠标坐标归一化为 -1 到 +1
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
}
window.addEventListener('mousemove', onMouseMove, false);
// 支持触摸设备
window.addEventListener('touchmove', (event) => {
    if(event.touches.length > 0) {
        mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.touches[0].clientY / window.innerHeight) * 2 + 1;
    }
}, false);


// --- 6. 动画主循环 (核心物理引擎) ---
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta(); // 获取帧间隔时间，保证运动平滑

    // 6.1 计算鼠标在 3D 空间的位置
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(interactionPlane);
    if (intersects.length > 0) {
        mouse3DVec.copy(intersects[0].point);
    } else {
        // 如果鼠标移出屏幕，重置到一个遥远的位置
        mouse3DVec.set(9999, 9999, 9999);
    }

    // 获取位置属性数组的引用
    const positions = particlesGeometry.attributes.position.array;

    // 6.2 遍历所有粒子进行物理计算
    for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
        // 当前粒子位置
        let px = positions[i];
        let py = positions[i + 1];
        let pz = positions[i + 2];

        // 初始目标位置
        let ox = originalPosArray[i];
        let oy = originalPosArray[i + 1];
        let oz = originalPosArray[i + 2];

        // 当前速度
        let vx = velocityArray[i];
        let vy = velocityArray[i + 1];
        let vz = velocityArray[i + 2];

        // --- 力 1: 鼠标斥力 ---
        // 计算粒子到 3D 鼠标点的距离平方 (比开平方根快)
        let dx = px - mouse3DVec.x;
        let dy = py - mouse3DVec.y;
        let dz = pz - mouse3DVec.z;
        let distSq = dx*dx + dy*dy + dz*dz;

        if (distSq < INTERACTION_RADIUS * INTERACTION_RADIUS) {
            let dist = Math.sqrt(distSq);
            // 距离越近，力越大。归一化向量 * 力度
            let force = (INTERACTION_RADIUS - dist) / INTERACTION_RADIUS; 
            vx += (dx / dist) * force * MOUSE_FORCE;
            vy += (dy / dist) * force * MOUSE_FORCE;
            vz += (dz / dist) * force * MOUSE_FORCE;
        }

        // --- 力 2: 回复力 (Spring Force) ---
        // 计算指向初始位置的向量，并乘以弹性系数
        vx += (ox - px) * RETURN_SPEED;
        vy += (oy - py) * RETURN_SPEED;
        vz += (oz - pz) * RETURN_SPEED;

        // --- 应用阻尼 (摩擦力) ---
        vx *= DAMPING;
        vy *= DAMPING;
        vz *= DAMPING;

        // --- 更新位置和速度数组 ---
        positions[i] += vx;
        positions[i + 1] += vy;
        positions[i + 2] += vz;
        
        velocityArray[i] = vx;
        velocityArray[i + 1] = vy;
        velocityArray[i + 2] = vz;
    }

    // 告诉 Three.js 位置属性已更新，需要重新渲染
    particlesGeometry.attributes.position.needsUpdate = true;
    
    // 给整个系统加一点缓慢的自转，增加动感
    particleSystem.rotation.y += delta * 0.05;

    renderer.render(scene, camera);
}

// --- 7. 窗口大小自适应 ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>